//globally importing the modular scale to make development easier;
@use "sass:map";
@use "sass:selector";
@use "sass:color";
@use "helpers";
@use "modularscale-sass/stylesheets/_modularscale.scss" as *;
@use "maps";
@use "sass:meta";
$colon: '\\3A ';
$modularscale: (
  base: 16px,
  ratio: 1.5,
);

@debug ms(-1);
@debug ms();
@debug ms(0);
@debug ms(1);
@debug ms(2);

$modularscale: (
  base: 1em,
  ratio: 1.3,
  20em: (
    ratio: 1.3,
  ),
  60em: (
    ratio: 1.6,
  ),
);

body {
  line-height: 1.3;
  margin: 0 auto;
  padding: 10% 5% 50%;
  max-width: 42em;
  font-size: ms(0);
}

@mixin breakpointLoop($breakpoints) {
  // create mobile first rule
  @content ( '' );
  // loop through the rules with media queries going up.
  @each $breakpointLabel, $value in $breakpoints {
    @media screen and (min-width: #{$value}) {
      @content ( $colon+$breakpointLabel );
    }
  }
}
@mixin directionModifierLoop($directionsMap) {
  //create the base all unit version first
  @content ( '', '' );
  //loop through the variations second
  @each $direction, $propertyDirectionMap in $directionsMap {
    @content ( '-'+$direction,$propertyDirectionMap );
  }
}
@mixin propertyDirectionMapLoop($propertyDirectionMap) {
  //loop through the variations second
  @each $label, $propertyDirection in $propertyDirectionMap {
    @content ( "-"+$propertyDirection );
  }
}
@mixin propertyValueLoop($units, $unitLoopMode) {
  // basic single layer value loop
  @if ($unitLoopMode == 'basic') {
    @each $unitLabel, $propertyValue in $units {
      @content ( $unitLabel, $propertyValue );
    }
  } @else {
    // complex color loop with value and modifier loop
    @each $unitLabel, $propertyValue in maps.$theme-palette {
      @content ( $unitLabel,  $propertyValue );
      @if ($unitLabel == black or $unitLabel == white) {
        @each $unitLabelModifier, $propertyValueModifier in map.get(maps.$units, opacity) {
          @content ( $unitLabel+'-'+$unitLabelModifier, color.change( $propertyValue , $alpha: $propertyValueModifier ));
        }
      } @else {
        @each $unitLabelModifier, $propertyValueModifier in $units {
          @content ( $unitLabel+'-'+$unitLabelModifier, color.scale( $propertyValue , $lightness: $propertyValueModifier ));
        }
      }
    }
  }
}

@mixin pseudoStateModifierLoop($states) {
  // create base rule with no modifications to state
  @content ( '','', '' );
  $stateClass: '';
  $pseudoLabel: '';
  @each $stateLabelModifier, $pseudoLabelModifier in $states {
    // active is not a true pseudo class but rather a style that reacts to its parent having active
    @if ($pseudoLabelModifier == active) {
      $stateClass: '.active >';
      $pseudoLabel: '';
      @content ($stateClass, $stateLabelModifier + $colon  , $pseudoLabel );
      $stateClass: '.active';
      $pseudoLabel: '';
      @content ($stateClass, $stateLabelModifier + $colon  , $pseudoLabel );
    } @else {
      $stateClass: '';
      $pseudoLabel: ':' + $pseudoLabelModifier;
      @content ($stateClass, $stateLabelModifier + $colon  , $pseudoLabel );
    }
  }
}

@each $type, $map in maps.$css-properties {
  $base: map.get($map, name);
  $separator: '_';
  @if ($base == '.') {
    $separator: '';
  }
  $dir: ();
  @if (map.get($map, direction)) {
    $dir: map.get(maps.$units, map.get($map, direction));
  }
  $bp: ();
  @if (map.get($map, responsive)) {
    $bp: map.get(maps.$units, breakpoints);
  }
  $unitLoopMode: 'basic';
  @if (map.has-key($map, loopMode)) {
    $unitLoopMode: map.get($map, loopMode);
  }
  $pseudoStates: ();
  @if (map.has-key($map, states)) {
    $pseudoStates: map.get(maps.$units, states);
  }

  @include breakpointLoop($bp) using ($breakpointLabel) {
    @include directionModifierLoop($dir) using ($labelDirectionMod, $propertyDirectionMap) {
      @include propertyValueLoop(map.get(maps.$units, map.get($map, unit)), $unitLoopMode) using
        ($unitLabel, $propertyValue) {
        @include pseudoStateModifierLoop($pseudoStates) using ($stateClass, $stateLabelModifier, $pseudoLabelModifier) {
          #{
            $stateClass
            + '.'
            + $stateLabelModifier
            + $base
            + $labelDirectionMod
            + $separator
            + $unitLabel
            + $breakpointLabel
            + $pseudoLabelModifier
            } {
            @each $prop in map.get($map, property) {
              @if (type-of($propertyDirectionMap) == 'map') {
                $prop-post: '';
                @if ($prop == 'border-radius') {
                  $prop: 'border';
                  $prop-post: '-radius';
                }
                @if ($prop == 'border-width') {
                  $prop: 'border';
                  $prop-post: '-width';
                }
                @include propertyDirectionMapLoop($propertyDirectionMap) using ($propertyDirection) {
                  #{ $prop + $propertyDirection + $prop-post }: $propertyValue;
                }
              } @else {
                #{ $prop }: $propertyValue;
              }
              // if direction is  x , y duplicate.
            }
          }
        }
      }
    }
  }
}

// Each CSS Utility Class
// If it is responsive. If it is loop through breakpoints
// If it has pseudo states. If it is loop through states
// If it has direction modifiers. If it is loop through directions.
// If color loop through color loop
// else loop through units
// End loops
// End Each
